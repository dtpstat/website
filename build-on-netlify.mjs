// @ts-check

/*
 * This script contains custom logic needed on Netlify. It is launched via netlify.toml.
 * See comments for details of each workaround.
 */

import { execa } from "execa";
import fs from "node:fs";

const mark = " [build-on-netlify.mjs] ";
const logStatement = (/** @type {string} */ message) => {
  /* eslint-disable no-console */
  console.log("");
  console.log(`=${mark}${"=".repeat(message.length - mark.length - 1)}`);
  console.log(message);
  console.log("=".repeat(message.length));
  console.log("");
  /* eslint-enable no-console */
};

/**
 * Because we use separate Netlify projects for staging and production, we end up
 * with two deployments for each commit on the main branch. This cannot be disabled.
 * To save CI time and to avoid needless website mirrors, we make deploy a dummy
 * website on the main branch of the staging project. All it does is redirecting
 * to a predefined destination.
 */
if (
  process.env.MAIN_BRANCH_REDIRECT_DESTINATION &&
  process.env.CONTEXT === "production" // = check for `main` branch on Netlify
) {
  logStatement(
    `Real website will not be deployed. All requests will be redirect to ${process.env.MAIN_BRANCH_REDIRECT_DESTINATION}`,
  );

  // @todo Investigate ways of making a dummy Netlify deploy without involving Next.js

  fs.renameSync("next.config.mjs", "next.config.mjs.bak");
  fs.renameSync("public", "public.bak");

  fs.writeFileSync(
    "next.config.mjs",
    `// Generated by ./build-on-netlify.mjs

export default {
  eslint: { ignoreDuringBuilds: true },
  typescript: { ignoreBuildErrors: true },

  pageExtensions: ["non-existing"],
  redirects: async () => [
    {
      source: "/:path*",
      destination: "${process.env.MAIN_BRANCH_REDIRECT_DESTINATION}",
      permanent: false,
    },
  ],
}`,
    "utf-8",
  );
} else {
  /** @type {Record<string, string>} */
  const envToWrite = {};

  /*
  * It transforms
  * variables available at build time and writes them into a dotenv file.
  * This file is then read by Next.js both at build time and run time.
  * /
 
  /*
   * Deploy previews and production release require different AUTH0_BASE_URL.
   * We cannot set this variable dynamically in the Netlify UI, So we define
   * it based on system variables available at build time:
   * https://docs.netlify.com/configure-builds/environment-variables/#read-only-variables
   */

  if (process.env.AUTH0_BASE_URL) {
    throw new Error(
      `Did not expect AUTH0_BASE_URL to be defined (=${process.env.AUTH0_BASE_URL}). Please remove it from Netlify UI or delete this code.`,
    );
  }

  envToWrite["AUTH0_BASE_URL"] =
    process.env.CONTEXT === "deploy-preview"
      ? process.env.DEPLOY_PRIME_URL
      : process.env.URL;

  if (!envToWrite["AUTH0_BASE_URL"]) {
    throw new Error(
      "Did not expect generated AUTH0_BASE_URL to be empty. Please check the values of CONTEXT / DEPLOY_PRIME_URL / URL.",
    );
  }

  /*
   * Write all defined variables into a dotenv file
   */

  const dotenvFilePath = ".env.production.local";

  if (fs.existsSync(dotenvFilePath)) {
    throw new Error(
      `Did not expect ${dotenvFilePath} to exist. Please delete it and make sure it is ignored by git.`,
    );
  }

  const serializedEnvToWrite = Object.entries(envToWrite)
    .map(([key, value]) => `${key}=${value}\n`)
    .join("");

  fs.writeFileSync(
    dotenvFilePath,
    `## Generated by ./build-on-netlify.mjs\n\n${serializedEnvToWrite}`,
  );

  logStatement(
    `Created ${dotenvFilePath} file with ${Object.values(envToWrite).join(
      ", ",
    )}`,
  );
}

// @ts-expect-error -- false-positive top-level await call is reported by VSCodeâ€™s tsc (needs investigation)
await execa("next", ["build"], { stdio: "inherit" });
